package vupx.backend.logging;

import haxe.CallStack;

import vupx.backend.other.MemoryUtil;

/**
 * A class to handle uncaught errors and crashes
 * 
 * Inspired in the Slushi Engine Crash Handler
 * 
 * Author: Slushi
 */
class VupxCrashHandler {
    /**
     * The version of the crash handler
     */
    public static final crashHandler_VERSION:String = "1.0.0";

	/**
	 * Initialize the crash handler of HXCPP
	 * 
	 * This is not a really a crash handler, is only used for 
	 * critical errors of HXCPP, nothing more
	 */
	public static function initHXCPPCrashHandler()
	{
		untyped __global__.__hxcpp_set_critical_error_handler(onHXCPPError);
	}

    /**
     * Handle uncaught errors and crashes of the Haxe code
     * 
     * This can't be prevent all crashes of Atmosphere or the program... so.. minull?
     * 
     * @param e The uncaught error
     */
    public static function onUncaughtError(e:Dynamic):Void {
		VpModulesManager.callModulesFunction(GENERAL_CRASH);

		var callStackText:String = "";
		var path:String = "";
		var callStack:Array<StackItem> = CallStack.exceptionStack(true);
		var dateNow:String = Date.now().toString().replace(" ", "_").replace(":", "'");

        path = VpStorage.getGameSDMCPath() + "engineLogs/crashes/VupxEngineCrash_" + dateNow + ".txt";

        for (stackItem in callStack)
		{
			switch (stackItem)
			{
				case FilePos(s, file, line, column):
					callStackText += file + " (line " + line + ")\n";
				case CFunction:
					callStackText += "Non-Haxe (C) Function";
				case Module(c):
					callStackText += 'Module ${c}';
				default:
					Sys.println(stackItem);
			}
		}

        if (!FileSystem.exists(VpStorage.getGameSDMCPath() + "engineLogs/crashes/"))
			FileSystem.createDirectory(VpStorage.getGameSDMCPath() + "engineLogs/crashes/");

        File.saveContent(path, buildCrashReportForFile(e, callStackText));

		VupxDebug.printToLogFileDirectly("\n\n-- ENGINE CRASH --------------------\nHaxe call stack:\n" + callStackText + "\nCrash error:\n" + e + "\n\nCrash report has been saved to:\n" + path + "\n----------------------\n\n");

		VpSwitch.showNXApplicationError(getErrorCodeFromErrorMessage(e), "Vupx Engine has crashed!\n\nError: " + e + "\n\nPress \"Details\" option for more information", "Haxe call stack:\n" + callStackText + "\n\nCrash error:\n" + e + "\n\nA crash report has been saved to:\n" + path);

		#if VUPX_DONT_CLOSE_AFTER_CRASH // If we don't want to finalize the engine after a crash (NOT RECOMMENDED...)
		VupxDebug.log("Doing nothing, continuing execution... Waiting for a critical crash maybe?", WARNING);
		#else
		// Call directly the engine finalization, we need exit of the program as quickly as possible
		VupxEngine.finalizeEngine();
		#end
    }

    /**
     * Build the crash report for the file
     * @param errorMessage The error message
     * @param callStack The Haxe call stack
     * @return String
     */
    private static function buildCrashReportForFile(errorMessage:String, callStack:String):String
	{
        // I extracted this code from Slushi Engine.. XD.
		var fullContents:String = '=====================\n';
		fullContents += 'Vupx Engine Crash Report - Crash Handler v${crashHandler_VERSION}\n';
		fullContents += '=====================\n';

		fullContents += '\n';

		fullContents += 'Generated by: Vupx Engine v${VupxEngine.VERSION} for project: "${VupxEngine.projectName}"\n';
		fullContents += 'System timestamp: ${Date.now()}\n';	

		fullContents += '\n';

		fullContents += '=====================\n';

		fullContents += '\n';

		fullContents += 'Crash message: ${errorMessage}\n';

		fullContents += 'Crash error code: ${getErrorCodeFromErrorMessage(errorMessage)}\n';

		fullContents += '\n';

		fullContents += '=====================\n';

        fullContents += 'If you think this is a bug OF THE ENGINE AND NOT THE PROJECT, please report it here: ???\n';
        fullContents += 'If you think this is a bug OF THE PROJECT ("${VupxEngine.projectName}"), please report it to the project developer.\n';

        fullContents += '=====================\n';

		fullContents += '\n';

		fullContents += 'More info:\n';

		fullContents += '\n';

		var currentState:String = Vupx.currentState != null ? Type.getClassName(Type.getClass(Vupx.currentState)) : 'No state loaded.';
		var currentSubState = Vupx.currentState.subState != null ? Type.getClassName(Type.getClass(Vupx.currentState.subState)) : 'No substate loaded.';

		fullContents += 'Vupx Current State: ${currentState}\n';
		fullContents += 'Vupx Current SubState: ${currentSubState}\n';

		fullContents += '\n';

		fullContents += 'Haxe Call Stack: \n${callStack}\n';

		fullContents += '=====================\n';

		fullContents += '\n';

        fullContents += 'Nintendo Switch Info:\n';

		fullContents += 'Console model: ${VpSwitch.getConsoleModel()}\n';
        fullContents += 'HorizonOS firmware version: ${VpSwitch.SWITCH_VERSION}\n';
		fullContents += 'Atmosph√®re version: ${VpSwitch.ATMOSPHERE_VERSION}\n';
        fullContents += 'In Applet mode: ${VpSwitch.isRunningAsApplet() ? "Yes" : "No"}\n';
        var totalMen:{used:UInt64, total:UInt64} = VpSwitch.getCurrentMemoryUsage();
        fullContents += 'Console Memory Used: ${VpUtils.convertBytesWithCast(totalMen.used)} / ${VpUtils.convertBytesWithCast(totalMen.total)}\n';

        fullContents += '\n=====================\n';

		fullContents += MemoryUtil.buildGCInfo();

		fullContents += '\n';

		fullContents += '=====================\n';

		return fullContents;
	}

	/**
	 * Handle critical errors of HXCPP
	 * @param message The error message
	 */
	private static function onHXCPPError(message:Dynamic):Void
	{
		var mainText:String = '\nHXCPP side critical error!:\n';

		var callStack:Array<StackItem> = CallStack.exceptionStack(true);
		var callStackText:String = "Haxe call stack:\n";

		for (stackItem in callStack)
		{
			switch (stackItem)
			{
				case FilePos(s, file, line, column):
					callStackText += file + " (line " + line + ")\n";
				case CFunction:
					callStackText += "Non-Haxe (C) Function\n";
				case Module(c):
					callStackText += 'Module ${c}\n';
				default:
					callStackText += stackItem + '\n';
			}
		}

		mainText += callStackText + '\n\nError: ' + message;

		var path:String = VpStorage.getGameSDMCPath() + "engineLogs/crashes/VupxEngineHXCPPCrash_" + Date.now().toString().replace(" ", "_").replace(":", "'") + ".txt";
		if (!FileSystem.exists(VpStorage.getGameSDMCPath() + "engineLogs/crashes/"))
			FileSystem.createDirectory(VpStorage.getGameSDMCPath() + "engineLogs/crashes/");
        File.saveContent(path, mainText);

		VupxDebug.printToLogFileDirectly(mainText);
		throw mainText;
	}

	/**
	 * Get an error code from an error message
	 * @param message The error message
	 * @return Int
	 */
	private static function getErrorCodeFromErrorMessage(message:String):Int {
		if (message == null || message == "") {
			return 0;
		}

		// TODO: Add more error codes based on the error message
		switch (message) {
			case "Null Object Reference":
				return 1609;
			default:
				return 0;
		}

		return 0;
	}
}